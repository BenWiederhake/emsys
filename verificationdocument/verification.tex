\documentclass[a4paper,parskip,headheight=38pt]{scrartcl} % article or scrartcl
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[%
  automark,
  headsepline                %% Separation line below the header
]{scrlayer-scrpage}
\usepackage[english]{babel}
\usepackage{hyphenat}
\usepackage[hidelinks]{hyperref}
\usepackage[top=1.4in, bottom=1.5in, left=1in, right=1in]{geometry}
\usepackage{lastpage}
\usepackage{csquotes}
\usepackage{microtype}
\usepackage{datetime}

\usepackage{url}

\usepackage{todonotes}

\usepackage[normalem]{ulem}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{csvsimple}

\usepackage{microtype}

\usepackage[hang]{footmisc}
\setlength{\footnotemargin}{3mm}

\usepackage{enumitem}

\usepackage{color}

\usepackage[export]{adjustbox}

\newcommand*{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

% \usepackage{multicol}
\usepackage{graphicx}
\usepackage{graphics}
% \usepackage{float}
% \usepackage{caption}

\parindent 0pt
\parskip 6pt

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\setkomafont{pagehead}{\normalfont\sffamily\footnotesize}
\addtolength{\headheight}{+13pt}
\lohead{Marlene Böhmer, s9meboeh@stud.uni-saarland.de, 2547718 \\
	Maximilian Köhl, s8makoeh@stud.uni-saarland.de, 2553525 \\
	Maximilian Schwenger, schwenger@stud.uni-saarland.de, 2542438\\
	Ben Wiederhake, s9bewied@stud.uni-saarland.de, 2541266}
\rohead{\includegraphics[height=36pt, right]{../logo/logo.png} \newline ES16, Verification Document, Group 6, Page {\thepage}/{\pageref*{LastPage}}}

\newtimeformat{mytime}{\twodigit{\THEHOUR}\twodigit{\THEMINUTE}\twodigit{\THESECOND}}
\settimeformat{mytime}
\newdateformat{mydate}{\twodigit{\THEYEAR}\twodigit{\THEMONTH}\twodigit{\THEDAY}}
\cfoot{\tiny\texttt{ID \mydate\today\currenttime}}
\chead{} % Needed because now the \subsections get displayed
\pagestyle{scrheadings}

% \renewcommand{\headrulewidth}{0pt}
% \addtolength{\textheight}{+30mm}
% \addtolength{\textwidth}{+50mm}
% \addtolength{\hoffset}{-7mm}

% \newcommand{\Omicron}{\ensuremath{\mathcal{O}}}
% \newcommand{\omicron}{\ensuremath{o}}
% \newcommand{\set}[1]{\{#1\}}
% \newcommand{\abs}[1]{\lvert #1 \rvert}

\DeclareMathOperator{\sinc}{sinc}

\newcommand{\incomplete}[1]{\textless{} #1 \textgreater{}}

\newcommand{\teststrat}[5]{
    \subsubsection{Test Strategy}
	\textbf{Component:} #1 \\
	\noindent\textbf{What should be tested?} \\
    \noindent #2 \\
	\noindent\textbf{How can it be tested?} \\
    \noindent\textcolor{blue}{Setup:} #3 \\
    \noindent\textcolor{blue}{Applicable Techniques:} #4 \\
	\noindent\textbf{What cannot be tested? Why?} \\
    \noindent #5
}

\newcommand{\testprot}[6]{
    \subsubsection{Test Protocol}
    \textbf{Component:} #1 \\
    \noindent\textbf{What should be tested?} \\
    \noindent #2 \\
    \noindent\textbf{How can it be tested?} \\
    \noindent\textcolor{blue}{Setup:} #3 \\
    \noindent\textcolor{blue}{Applicable Techniques:} #4 \\
    \noindent\textbf{What cannot be tested? Why?} \\
    \noindent #5
    \noindent\textbf{Results:} \\
    \noindent #6
}

\newcommand{\ie}{i.e.}

\newcommand{\BLACK}{\textbf{Integration test: }}
\newcommand{\WHITE}{\textbf{Unit test: }}

\begin{document}

\section{Overview}

On a grand scheme the software is divided into the following subcomponents:

\begin{itemize}
	\item Controller
	\item Traffic Cop Eyes
	\item Blind Traffic Cop 
	\item RHR
	\item Victim Direction\footnote{We will present a test protocol
   for this component.}
	\item Victim Finder
	\item Path Finder
	\item Path Executor
	\item Pickup Artist
\end{itemize}

Each of those components is subject of one or more test strategies either for
the whole component at once, or their subcomponents separately.
\subsection{Controller}
\subsubsection{Purpose}
	Connects each component's inputs and outputs. Steps appropriate components
    based on the Blind Cop's output. This component does not incorporate further
    logic.
\teststrat{Controller}{
    The correct connection between the Tin Bot's different subcomponents, \ie,
    the correct overall behavior for a single Tin Bot without taking any T2T
    connection into account.
}{
    Maze, Victim, one Tin Bot including all LEDs, LPS, debug monitor.
}{
    \BLACK Setup the maze. Place the victim and the Tin Bot inside
    appropriately. Setup
    the LPS and make sure that a Bluetooth connection between the LPS, the Tin
    Bot, and the debug monitor is established. Turn on the E-Puck and evaluate
    the behavior based on movements and visual feedback by the LEDs.
}{
    Correctness of subcomponents separately is not tested, because they are
    covered in other, more appropriate test cases. Moreover, the T2T connection
    is not tested for the same reasoning.
}
%
\subsection{Traffic Cop Eyes}
\subsubsection{Purpose}
Connects sensor data with remaining components. Issues requests for other
components to start their work.
\todo[inline]{elaborate a bit}
\teststrat{Traffic Cop Eyes}{
    Correct behavior based on given sensor data.
}{
    Part \rom{1}: MatLab, compiled code. Part \rom{2}: Full Setup, \ie, LPS,
    victim, Tin Bot(s), debug monitor, maze.
}{
    Part \rom{1}: \WHITE Run the test cases from the virtual prototype, but use
    actual
    compiled code instead of the Simulink model. Check for correctness based
    on the output. \\
    Part \rom{2}: \BLACK Run full process, check for ignorance towards incoming
    signals
    even though the intended behavior dictates a reaction. 
}{
    There are no unit tests for this component due to its importance and
    simplicity. So bugs are unlikely and close to impossible to remain
    unnoticed.
}
%
\subsection{Blind Traffic Cop:}
\subsubsection{Purpose}
An arbiter for the subcomponents. It does not take sensor data into account but
relies on other component's outputs for the decision.
\teststrat{Blind Traffic Cop}{
    Correct arbitration of the access to the motors.
}{
    Full Setup.
}{
    \BLACK Each component has a signature behavior and
    their distinction is clear, so a conflict or an incorrect arbitration can be
    spotted easily.
}{
    It is not tested, whether the controller actually uses the Blind Cop's
    output or decides on its own. If it were so the Tin Bot's behavior would be
    spurious, or correct. In the latter case, we would assume the Blind Cop to
    be correct, even though it is not used at all.
}
%
\subsection{Right-Hand Rule}
\subsubsection{Purpose}
Implementation of the right-hand rule\footnote{For a detailed description,
please see 
\url{https://en.wikipedia.org/wiki/Maze_solving_algorithm\#Wall_follower}
}.
\teststrat{Right-Hand-Rule Obedience}{
    The Tin Bot is supposed to walk straight until sensing a wall. Then, it
    should follow it having the wall on its right-hand side.
}{
    Tin Bot, LPS, debug monitor, maze.
}{
    \BLACK Setup the LPS and the maze. Place a single Tin Bot in the maze and
    turn it
    on. Start the Tin Bot and wait an appropriate amount of time based on the
    maze's layout.

    Check debug data for disagreements with the intended behavior.
}{
    Collision avoidance is not tested on a detailed level, i.e. scraping along
    the wall will not be detectable. This, however, is subject of a dedicated
    test.
}
%
\subsection{Victim Finder}
\subsubsection{Purpose}
Starts victim direction. Manages gathered data about the victim, i.e. discards
old information and start computation for new data accordingly.

\teststrat{Victim Directing toggling}{
    When a signal from the victim is received, the victim direction components
    is supposed to be toggled. Only after having traveled an appropriate amount
    of time, another measurement should be initiated.
}{
    Victim, maze, LPS, Tin Bot.
}{
    \BLACK Setup the maze as well as the LPS. Place the victim and the
    Tin Bot in the
    maze and turn them on. Wait for the Tin Bot to receive a signal and check
    for the component's signature movement, \ie, turning a full circle.

    Wait for the second measurement to be fully performed, then turn off the Tin
    Bot and measure the traveled distance.
}{
    The correctness of the signals and the output are not tested, because they
    are subject of their own test cases.
}

\begin{figure}[t]
\includegraphics[width=\textwidth, height=4cm]{victimdirectionbadplot.pdf}
\caption{Data obtained by running victim direction. Reference data computed
based on a bird's eye view image. Plot shows histogram of deviation from
measured data to the reference value.}
\label{fig:vddatabad}
\end{figure}
\begin{figure}[t]
\includegraphics[width=\textwidth, height=4cm]{victimdirectionbadplot.pdf}
\caption{Data obtained by running victim direction. Reference data computed
based on a bird's eye view image. Plot shows histogram of deviation from
measured data to the reference value.}
\label{fig:vddatagood}
\end{figure}

\subsection{Victim Direction}
\subsubsection{Purpose}
Turns the E-Puck and computes angle/position to the victim.
\testprot{Victim Direction Computation}{
    Victim direction is supposed to approximate the normalized angle from its
    current position to the victim. The computation's correctness is tested
    here.
}{
    Part \rom{1}: MatLab, compiled code.
    Part \rom{2}: LPS, debug monitor, Tin Bot, victim.
}{
    Part \rom{1}: \WHITE Start test case from virtual prototype in MatLab, but
    use
    compiled code
    instead of Simulink model. Check the output.
    Part \rom{2}: \BLACK Setup the LPS, place and turn on the Tin Bot as well as
    the
    victim. Make sure a Bluetooth connection between the debug monitor, the Tin
    Bot, and the LPS has been established. 

    Run the Tin Bot, wait until a measurement has been completed, and the result
    has been sent to the debug monitor. Check for approximative correctness.
}{
    Bluetooth connection and correctness of signals are not tested. The former
    one is assumed to be correct, the latter one is subject to its own test
    cases.
}{
    The acquired data can be seen in Fig. \ref{fig:vddatabad}. As we can see,
    the computed values differ significantly from the actual angles. As reason
    we identified reflections caused by the environment. To circumvent the
    problem, we covered the boundary in cellular rubber. This should prevent
    most reflections. Re-running the experiment revealed that now the
    measurement are sufficiently correct, as can be seen in Fig. \ref
    {fig:vddatagood}.
}

\subsection{Path Finder}
\subsubsection{Purpose}
Computes a path from the current position to the victim based on the internal map consisting of data gathered via proximity sensors and other Tin Bot's broadcasts.
\teststrat{Path Finder State Machine}{
    The path finder should output a given solution path in the correct order and
    raise flags for the last and penultimate waypoint appropriately.
}{
    MatLab, compiled code.
}{
    \WHITE Start respective MatLab test case from the virtual prototype using
    the compiled code instead of the Simulink model. Check the outputs.

    Additionally, run the unit tests and check for failing assignments.
}{
    Sanity of given path and especially the finiteness of thereof is not tested.
    This is part of a different test.
}

\teststrat{Path Finder Search Algorithm}{
    An optimal path based on the internal map should be found while the memory
    needed should be bounded statically.
}{
    Compiled code.
}{
    Unit tests check optimality and correctness. Static checks ensure memory
    bound.
}{
    Invalid input maps.
}

\subsection{Path Executor}
Moves the Tin Bot to a given position minding the walls.
\teststrat{Path Executor}{
    A given waypoint should be reached by the Tin Bot using a straight line
    path. If there is an obstacle blocking the way, the Tin Bot should stop.
    Additionally, if the appropriate flag is set, the path executor should turn
    the Tin Bot by $180\deg$ and reach the way point in the reverse gear.
}{
    Tin Bot, LPS, walls.
}{
    \BLACK After receiving any valid waypoint, the Tin Bot should
    only stop if the waypoint or a wall is reached. Turn sequence should be
    initiated if the flag is set.
}{
    The invalidity of a waypoint is not checked explicitly, if the point is
    unreachable, the Tin Bot will stop in front of the boundary as if it was a
    wall.
}

\subsection{Pickup Artist}
\subsubsection{Purpose}
Allows robustness against inaccuracies in the victim's computed position by
initiating a small scale search after reaching the expected position.
\teststrat{Pickup Artist}{
    If the victim's position differs from the computed one, the Tin Bot is
    supposed to continue driving towards it until the victim is picked up. If
    the difference is too large, the Tin Bot is supposed to shut down.
}{
    LPS, TB, victim, compiled code.
}{
    \BLACK Setup LPS, turn on the Tin Bot and the victim. Give the
    \emph{last} waypoint which is differing slightly from the victim's actual
    position. The waypoint has to be the last one to ensure that the Tin Bot
    will be in the right position to initiate the pick up process. Check if the
    pickup succeeds.

    Afterwards, the last waypoint is sent while the victim is entirely out of
    reach. 15 seconds after reaching the waypoint, a full shutdown is expected.

    The unit test ensures that state transitions are taken appropriately.
}{
    Walls behind the victim's expected position will not be detected. Therefore,
    there is no point in testing for such a behavior.
}

\subsection{Collision Avoidance}
When the Tin Bot moves too close to a wall, independent of the current mode, it
should stop before any collision takes place.
\teststrat{Collision Avoidance}{
    No wall, neither formerly known ones, no newly added ones, must be knocked
    over.
}{
    Maze, LPS, Tin Bot.
}{
    \BLACK Run different modes in different settings and make sure no
    wall is knocked over.
}{
    Correct overall behavior, because this is subject of own test strategies.
}

\section{Hardware} 
The hardware is divides into two parts: The environment, and the connection
between the main components, \ie, the Raspberry Pi, and the E-Puck. 
The connection between the components and their respective sensors and actuators
is verified using the following test strategies.

\subsection{Connection Extension Board to E-Puck}

\teststrat{Custom Extension Board Connection Frequency}{
    We guarantee a real time upper bound on the frequency in which sensor data
    is received and can then be processed. The time between two received
    sensor data packages is \todo[inline]{FREQUENCY}ms.

    We test the frequency in which data is received and computed the maximal
    time needed for all interrupt service routine to run through, such that the
    stated frequency can be guaranteed.
}{
    Oscilloscope, custom extension board, E-Puck.
}{
    We directly measure the signals from the extension board sent using the
    i\textsuperscript{2}c protocol. We send signals to an IR-Sensor to see
    whether the received signal is correct.
}{
   We do not measure whether an amplitude is registered only if the signal is
   strong enough. The reason for this is that we regulate the signals stability
   on with software, therefore we do not mind the actual intensity. Moreover, we
   designed the IR-Sensors in a way that the sensitivity fits our needs based on
   empirical results.
}

\subsection{Connection between the Raspberry Pi as LPS and the E-Puck as Tin Bot
via Bluetooth}

\teststrat{LPS Update Frequency}{
    If the initial setup is completed, the LPS is supposed to send location data
    to the Tin Bot approximately every two seconds without any hard guarantees.
    However, the process of receiving and processing the data should not take
    more than three seconds. Progress in this regard is supposed to be signaled
    by toggling a designated LED.
}{
    LPS, debug monitor, Tin Bot with a designated LED.
}{
    Make sure the initial setup is completed, \ie, the debug monitor indicates a
    Bluetooth connection and the LPS has recognized the Tin Bot. Now, the time
    between toggles is measured and should not exceed three seconds.
}{
    The correctness of the LPS data is not tested. We assured that the data is
    correct in separate tests, though. Moreover, the location data has to be
    correct relative to the measured location data of other Tin Bots, which
    depends on the camera and is robust by construction.
}

\subsection{Victim}

\teststrat{Victim Actuators}{
    The victim shall send IR-Signals and a LED shall be on after turning the
    victim on. The signals shall be in agreement with the SOS-protocol.
}{
    Oscilloscope, Victim, Victim's power LED, IR-Sensors.
}{
    Turn on the victim and check the LED using visual feedback. Make sure that
    there is a clear sight between the victim and the IR-Sensors. Check the
    received signal using the oscilloscope and compare against the expected
    pattern.
}{
    We cannot test whether the signal originates at the victim or any other
    source, e.g.\ a malevolent agent turning on or off a nearby device using a
    similar signal.
}

\section{Environment}

Certain invariants appear throughout the whole project. We assure their validity
with the following test strategies.

\subsection{Proximity Sensor Data}

We did not rely on the vendor's information regarding the proximity sensor data
but conducted a series of tests. 

\teststrat{Proximity Sensor Data Conversion}{
    We needed to convert the given data into an approximated distance to an
    obstacle. 
}{
    E-Puck, debug monitor, walls.
}{
    Place the E-Puck in a fixed distance to a wall, obtain the data given by
    the proximity sensors using the debug monitor. Acquire 30 data points.
    Change the position and repeat until the distance is 6cm.

    Compute the median of each distance and use it as data point for an
    exponential trend line.
}

The result can be found in Fig. \ref{fig:proxdata}.
\begin{figure}[t]
\noindent\includegraphics[width=\textwidth]{Proximitygraph.eps}
\label{fig:proxdata}
\caption{$x$-Axis: Raw data given by the proximity sensors. $y$-Axis: Measured
distance. The trend line function can be used to convert given proximity data
to an approximated distance to an obstacle.}
\end{figure}

\subsection{IR-Signals}
We assume that the IR-Signals are stable and originate from the victim only.

\teststrat{IR-Stabilization}{
    The IR-Signal recognition should be robust against minor disturbances, e.g.
    due interferences with distant reflections or similar.
    Those unwanted peaks are supposed to be filtered out.
}{
    Tin Bot, LPS, Victim.
}{
    Integration test: When there is no clear line of sight between the Tin Bot
    and the victim, no LED should light up.
}{
    Correct overall behavior, because this is subject of own test strategies.
}

\teststrat{IR Anti Reflection}{
    There are not supposed to be elements around the maze reflecting the IR
    signals unwantedly. Therefore, we coated the borders in cellular rubber
    absorbing signals rather than reflecting them. This behavior is tested.
}{
    Tin Bot, maze, spectators, borders.
}{
    Integration Test: 
    The Tin Bot is placed in the maze and turned on, but not
    started. In this mode, it reports incoming and deemed-valid signals using
    its LEDs. 

    The victim is turned on and moved around in the maze. There should not be
    any lighting LEDs other than the expected ones.
}{
    Correct overall behavior, because this is subject of own test strategies.
}

Moreover, since the Tin Bots do not have access to ground sensors, we tested the
environment to be a safe playground regardless.

\teststrat{Fence}{
    The fences have to make sure that the Tin Bot will not fall off the table.
}{
    Tin Bot, Maze, LPS.
}{
    Unit test: Send move signal to Tin Bot and let it run towards the table's
    edge. \textbf{Caution:} Make sure the Tin Bot will be caught if the test
    fails.
}{
    Correct overall behavior, because this is subject of own test strategies.
}

\section{Actuators}

The actuators are tested in a most isolated environment.

\teststrat{Motors}{
    When setting the appropriate register values, the E-Puck is supposed to
    start driving.
}{
    Tin Bot, LPS, debug monitor.
}{
    Unit Test: Turn on the Tin Bot, setup the LPS. Make sure, a connection
    between all components is established. Send a signal to the E-Puck setting
    the respective registers values. Ensure that the E-Puck starts moving.
}{
    Loss of packets due to Bluetooth problems are not tested, neither are faulty
    registers and memory. Such faults, however, become evident very quickly.
}

\teststrat{LEDs}{
    When setting the appropriate register values, the E-Puck is supposed to
    trigger the LEDs.
}{
    Tin Bot, LPS, debug monitor.
}{
    Unit Test: Turn on the Tin Bot, setup the LPS. Make sure, a connection
    between all components is established. Send a signal to the E-Puck setting
    the respective registers values. Ensure that the E-Puck starts triggering
    the LEDs.
}{
    Loss of packets due to Bluetooth problems are not tested, neither are faulty
    registers and memory. Such faults, however, become evident very quickly.
}

\end{document}